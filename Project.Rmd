---
title: "Outliers detection na podstawie zbioru Airbnb New York City 2019"
author: "Jarosław Szewczyk"
date: "`r format(Sys.time(), '%d.%m.%Y')`"
output:
  rmdformats::readthedown:
      highlight: default
---
<style>

#sidebar
{
  position: fixed;
  top: 0;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  height: 100%;
  background: #14213d; /* Background of left center sidebar */
  z-index: 200;
  font-size: 16px;
}

#sidebar a
{
  color: #ffffff; /* Czcionka spisu treści */
  font-weight: normal;
}

#sidebar h2
{
  color: #14213d;
  background: #fca311; /* Background of left top sidebar */
  text-decoration: underline;
  cursor: pointer;
}

#sidebar h2 a
{
  color: #14213d;
}

#sidebar a:hover
{
  color: #ffffff;
  background-color: #bf0063;
  cursor: pointer;
}

td {
  color: #f7f3eb;
}

code.sourceCode.r
{
  background: #f7f3eb;
  color: #fca311;
}

h1
{
  color: #14213d;
  text-decoration: none;
}

h2, h3, h4, h5, h6, legend
{
  color: #14213d;
  text-decoration: underline;
  text-decoration-color: #bf0063;
}

#postamble
{
  background: #fca311; /* Background of about me section */
  border-top: solid 10px #bf0063; /* Top line about me section*/
  font-family: "Lato","proxima-nova","Helvetica Neue",Arial,sans-serif;
  font-size: 90%;
  z-index: 400;
  padding: 12px;
}

#postamble .status
{
  color: #14213d;
  background: red; /* Background of about me section */
  border-top: solid 10px #211103;
  font-family: "Lato","proxima-nova","Helvetica Neue",Arial,sans-serif;
  font-size: 90%;
  z-index: 400;
  padding: 12px;
}

#postamble .author
{
  color: #14213d;
  font-weight: bold;
}

#postamble .date
{
  color: #14213d;
}

p
{
  color: #14213d;
}

#content
{
  background: #e5e5e5;
}

#content pre
{
  border: 3px solid #bf0063;
  color: #fca311;
}

#content div.sourceCode
{
  background: #e5e5e5;
}

pre
{
  background-color: #14213d;
  color: #14213d;
}

pre code
{
  color: #fca311;
}

#toc ul.nav li.active ul li.active a
{
  background-color: #fca311;
  color: #14213d !important;
  font-weight: normal !important;
}

#toc ul.nav li.active ul li a
{
  background-color: #14213d;
  color: #ffffff;
  font-weight: normal;
  border-right: solid 1px #14213d !important;
}

#toc ul.nav li.active a
{
  color: #ffffff !important;
  background-color: #fca311
  border-right: solid 0px black !important;
}

#toc ul.nav > li.active > a
{
  color: #14213d;
  background-color: #fca311;
}

#main table:not(.dataTable) td, #main table:not(.dataTable) th
{
  background: #00bf83;
  border: #00bf83; /* Przerwy */
}

/* Code highlight */

code span.fu
{
  color: #fca311;
}

code span.sc
{
  color: #fca311;
}

code span.dv
{
  color: #fca311;
}

code span.in
{
  color: #fca311;
}

code span.cn
{
  color: #fca311;
 
}

code span.st
{
  color: #fca311;
}

code span.ot
{
  color: #fca311;
}

code span.cf
{
  color: #fca311;
}

code span.co
{
  color: #fca311;
}

code span.fl
{
  color: #fca311;
}

code span.at
{
  color: #fca311;
}

</style>
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Przygotowanie środowiska

Zainstalowanie i załadowanie pakietów
```{r}
library("dplyr")
library("rmarkdown")
library("rmdformats")
library("robustbase")
```

Wczytanie zbioru danych
```{r}
data <- read.csv("AB_NYC_2019.csv", sep = ",")
```

Wstępna analiza zbioru danych
```{r}
#Wymiary zbioru
dim(data)

#Zmienne i typy danych
str(data)

#Braki danych
colSums(is.na(data))
```

# Wykrywanie elementów odstających - 1 wymiar

## Reguła 3 sigma
```{r}
threesigma.rule <- function(data, var, t = 3, RemoveNAs = FALSE){
  mu <- mean(data[[var]], na.rm = RemoveNAs)
  sigma <- sd(data[[var]], na.rm = RemoveNAs)
  out <- abs(data[[var]] - mu) > t*sigma
  data.frame(id = data$id[out], var = data[[var]][out])
}

outliers_threesigma <- threesigma.rule(data, "price")
head(outliers_threesigma, 5)
```

## Metoda Tukeya
```{r}
outliers <- function(data, var, coef = 1.5) {
  bp <- boxplot(data[[var]], plot = FALSE)
  out <- bp$out
  stats <- boxplot.stats(data[[var]], coef = coef, do.conf = FALSE, do.out = TRUE)
  data.frame(id = data$id[data[[var]] %in% stats$out], var = data[[var]][data[[var]] %in% stats$out])
}

outliers_Tukey <- outliers(data, "price")
head(outliers_Tukey, 5)
```

## Reguła Hampela
```{r}
hampel.rule <- function(data, var_name, t = 3, RemoveNAs = FALSE){
  x <- data[[var_name]]
  mu <- median(x, na.rm = RemoveNAs)
  sig <- mad(x, na.rm = RemoveNAs)
  out <- which(abs(x - mu) > t*sig)
  if (length(out) > 0) {
    data.frame(id = data$id[out], value = x[out])
  } else {
    message("Brak wartości spełniających kryteria.")
    return(NULL)
  }
}

outliers_hampel <- hampel.rule(data, "price")
head(outliers_hampel, 5)
```

## Z-score
```{r}
data$z_scores <- (abs(data$price - mean(data$price))/sd(data$price))
outliers_zscore_sd <- data[data$z_scores > 3,][,c("id", "price")]
head(outliers_zscore_sd, 5)

data$z_scores <- (abs(data$price - median(data$price))/mad(data$price))
outliers_zscore_mad <- data[data$z_scores > 3.5,][,c("id", "price")]
head(outliers_zscore_mad, 5)
```

Do wykrycia wartości odstających można podejść podobnie jak do prognoz, które stawiane są różnymi metodami. Racjonalnym wyborem wydaje się być wyciąganie średniej z prognoz uzyskanych na podstawie różnych metod. W przypadku wartości odstających analogią może być wybór tych obserwacji, które zostały zaklasyfikowane jako outliery przez wszystkie metody lub jak największą liczbę metod.

Ramka danych z podsumowaniem wyników - 1 wymiar
```{r}
data_one_dim <- data
```

Zdefiniowanie dla każdej z metod zmiennej om (outliers membership) świadczącej o przynależności do grupy outlierów
```{r}
data_one_dim$om1 <- as.numeric(data$id %in% outliers_threesigma$id)
data_one_dim$om2 <- as.numeric(data$id %in% outliers_Tukey$id)
data_one_dim$om3 <- as.numeric(data$id %in% outliers_hampel$id)
data_one_dim$om4 <- as.numeric(data$id %in% outliers_zscore_sd$id)
data_one_dim$om5 <- as.numeric(data$id %in% outliers_zscore_mad$id)
```

Tabela ze wskazaniami
```{r}
outliers_membership <- grep("om.$", names(data_one_dim), value=TRUE)
data_one_dim$count <- rowSums(data_one_dim[, outliers_membership])
table(data_one_dim$count)
```

Które metody nie wskazały przynależności do grupy outlierów?
```{r}
colSums(data_one_dim[data_one_dim$count == 3, c("id", outliers_membership)])
```

Wartość dla zmiennej 'price', od której w oparciu o wszystkie metody zaczyna się grupa outlierów
```{r}
outlier_one_dim_min <- min(data_one_dim[data_one_dim$count == 5, c("id", "price")])
outlier_one_dim_min
```

# Wykrywanie elementów odstających - 2 wymiary lub więcej

```{r}

```